import{initialFilesystem as r,getInitialCwd as t}from"./structure.js";import e from"./persistence.js";export default new class{constructor(){this.fs=null,this.cwd="/",this.init()}init(){this.fs=JSON.parse(JSON.stringify(r)),this.cwd=t()}getCwd(){return this.cwd}setCwd(r){const t=this.resolvePath(r),e=this.getNode(t);if(!e)throw new Error(`No such directory: ${r}`);if("directory"!==e.type)throw new Error(`Not a directory: ${r}`);this.cwd=t}resolvePath(r){if(!r||"."===r)return this.cwd;if("~"===r)return"/home/hacker";if(r.startsWith("/"))return this._normalizePath(r);const t="/"===this.cwd?"/"+r:this.cwd+"/"+r;return this._normalizePath(t)}_normalizePath(r){const t=r.split("/").filter(r=>r&&"."!==r),e=[];for(const r of t)".."===r?e.length>0&&e.pop():e.push(r);return"/"+e.join("/")}getNode(r){const t=this.resolvePath(r);if("/"===t)return this.fs["/"];const e=t.split("/").filter(r=>r);let i=this.fs["/"];for(const r of e){if(!i||"directory"!==i.type)return null;if(!i.children||!i.children[r])return null;i=i.children[r]}return i}exists(r){return null!==this.getNode(r)}isDirectory(r){const t=this.getNode(r);return null!==t&&"directory"===t.type}isFile(r){const t=this.getNode(r);return null!==t&&"file"===t.type}readFile(r){const t=this.getNode(r);if(!t)throw new Error(`No such file: ${r}`);if("file"!==t.type)throw new Error(`Is a directory: ${r}`);if("restricted"===t.permissions)throw new Error(`Permission denied: ${r}`);return t.content||""}listDirectory(r=this.cwd,t=!1){const e=this.resolvePath(r),i=this.getNode(e);if(!i)throw new Error(`No such directory: ${r}`);if("directory"!==i.type)throw new Error(`Not a directory: ${r}`);const o=[];if(i.children)for(const[r,e]of Object.entries(i.children))!t&&r.startsWith(".")||o.push({name:r,type:e.type,permissions:e.permissions||"normal"});return o.sort((r,t)=>"directory"===r.type&&"file"===t.type?-1:"file"===r.type&&"directory"===t.type?1:r.name.localeCompare(t.name))}createDirectory(r){const t=this.resolvePath(r).split("/").filter(r=>r),i=t.pop(),o="/"+t.join("/"),s=this.getNode(o);if(!s)throw new Error(`No such directory: ${o}`);if("directory"!==s.type)throw new Error(`Not a directory: ${o}`);if(s.children[i])throw new Error(`File exists: ${r}`);s.children[i]={type:"directory",children:{}},e.save()}createFile(r,t=""){const i=this.resolvePath(r).split("/").filter(r=>r),o=i.pop(),s="/"+i.join("/"),n=this.getNode(s);if(!n)throw new Error(`No such directory: ${s}`);if("directory"!==n.type)throw new Error(`Not a directory: ${s}`);if(n.children[o]){if("file"===n.children[o].type)return;throw new Error(`Is a directory: ${r}`)}n.children[o]={type:"file",content:t},e.save()}delete(r,t=!1){const i=this.resolvePath(r);if("/"===i)throw new Error("Cannot delete root directory");const o=this.getNode(i);if(!o)throw new Error(`No such file or directory: ${r}`);if("directory"===o.type&&!t&&Object.keys(o.children||{}).length>0)throw new Error(`Directory not empty: ${r}`);const s=i.split("/").filter(r=>r),n=s.pop(),c="/"+s.join("/"),h=this.getNode(c);h&&h.children&&delete h.children[n],e.save()}copy(r,t){const i=this.getNode(r);if(!i)throw new Error(`No such file or directory: ${r}`);const o=JSON.parse(JSON.stringify(i)),s=this.resolvePath(t).split("/").filter(r=>r),n=s.pop(),c="/"+s.join("/"),h=this.getNode(c);if(!h)throw new Error(`No such directory: ${c}`);if("directory"!==h.type)throw new Error(`Not a directory: ${c}`);h.children[n]=o,e.save()}move(r,t){this.copy(r,t),this.delete(r,!0)}reset(){this.init()}serialize(){return JSON.stringify({fs:this.fs,cwd:this.cwd})}deserialize(r){try{const t=JSON.parse(r);t.fs&&t.cwd&&(this.fs=t.fs,this.cwd=t.cwd)}catch(r){console.error("Failed to deserialize filesystem:",r),this.init()}}};